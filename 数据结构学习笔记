
0.散列表：
	散列思想：利用数组支持下标随机访问的特性，散列表其实是数组的一种拓展
	散列函数：①散列函数计算得到的散列值是一个非负整数；②如果key1 = key2，那hash(key1) == hash(key2) ③如果key1 ≠ key2，那hash(key1) ≠ hash(key2) 
	散列冲突：①开放寻址法：如果出现冲突，就重新探测一个位置插入。
				线性探测：一个一个往后找，有位置则插入，没有就继续往后找；删除的时候不能直接删，需要标记为删除，查找时遇到删除标记的需要继续往后找。
				二次探测：跟线性探测很像，线性探测每次探测的步长是1，二次探测的步长就是原来的“二次方”
				双重散列：不仅用一个散列函数，当遇到位置被占用时，再用第二个散列函数，以此类推
				装载因子：表示空位的多少，散列表的装载因子=填入表中的元素个数/散列表的长度
			②链表法：每个“桶（bucket）”或者“槽（slot）”会对应一条链表，所有散列值相同的元素都放到相同槽位对应的链表中
	应用案例：word文档的单词拼写检查：
		常用的单词有20w个，一个单词10字母，一个字母占1字节（byte） = 8位（bit），20w=200w byte = 2000 kb = 2mb，将其放入内存中，用散列表存储整个英文词典，当输入某个单词时就去查找，找到则拼写正确

		
	若是在极端情况下，有些恶意的攻击者，还有可能通过精心构造的数据，使得所有的数据经过散列函数之后，都散列到同一个槽里。如果我们使用的是基于链表的冲突解决方法，那这个时候，散列表就会退化为链表，查询的时间复杂度就从O(1)急剧退化为O(n)。
	如果散列表中有10万个数据，退化后的散列表查询的效率就下降了10万倍。更直接点说，如果之前运行100次查询只需要0.1秒，那现在就需要1万秒。这样就有可能因为查询操作消耗大量CPU或者线程资源，导致系统无法响应其他请求，从而达到拒绝服务攻击（DoS）的目的。这也就是散列表碰撞攻击的基本原理。

 如何设计散列函数？ 散列函数的设计不能太复杂，散列函数生成的值要尽可能随机并且均匀分布
 装载因子过大？ 启动动态扩容，重新申请内存空间，重新计算哈希值，搬迁数据到新的散列表上
 如何避免低效的扩容？避免一次性扩容耗时过多，可以分批完成，当装载因子达到阈值时，只申请空间，不搬迁数据，当有新数据插入时，将数据插入新散列表中并从老散列表中取一个放入新的，一点点的搬迁。这个期间查找的时候，需要先查新散列，没有找到再查老散列表。
 如何选择冲突解决方法？
	1.当数据量比较小、装载因子小的时候，适合采用开放寻址法。这也是Java中的ThreadLocalMap使用开放寻址法解决散列冲突的原因。
	2.基于链表的散列冲突处理方法比较适合存储大对象、大数据量的散列表，而且，比起开放寻址法，它更加灵活，支持更多的优化策略，比如用红黑树代替链表。
 工业级散列表举例分析：Java中的HashMa
	1.HashMap默认的初始大小是16
	2.最大装载因子默认是0.75，当元素超过capacity*0.75时，启动扩容为原来的2倍
	3.散列冲突解决方法：底层采用链表，jdk1.8版本之后，当链表过长（超过8）时，转为红黑树，利用红黑树快速增删改查的特定。当小于8个时又退化回链表
	4.散列函数：int h = key.hashCode()； (h ^ (h >>> 16)) & (capicity -1)

1.跳表：使用空间换时间的设计思路，通过构建多级索引来提高查询的效率，实现了基于链表的“二分查找”。每两个节点之间选一个节点抽取到上一层作为索引，以此类推抽出多层，每次查找时就能减少遍历个数。
	动态更新：插入时使用随机函数将节点插入部分索引层中
	
	
1.哈希：
哈希算法：将任意长度的二进制值串映射为固定长度的二进制值串
哈希值：通过原始数据映射之后得到的二进制值串就是哈希值
特点：①单向 ②敏感，改一个结果也不同 ③冲突小（无法零冲突） ④高效 ⑤很难反向推导
应用场景： ①安全加密，例如MD5，SHA，相同字符串二次加密后得到密文相同；
		 ②唯一标识，例如图库中寻找一张图片是否存在，截取前中后各100字节通过哈希算法，得到哈希值
		 ③数据校验，例如bt下载，文件可能被分成多块，下载后再组装，防止被恶意篡改，对分块取哈希，下载后再校验哈希值
		 ④散列函数：用于将元素散列分布，不关注是否能反向解密和个别冲突，只要分布平均，以及性能快慢
		（开放寻址法：当哈希冲突时，用某种策略例如线性探查二次探查，找下一个空的哈希槽存放元素）
		⑤负载均衡，会话粘滞（让同一个客户端的所有请求都去到一个服务器），采用映射表则浪费空间，而且维护成本高。
		方案：用客户端ip和会话id计算哈希值，再将哈希值与服务器列表取模运算，得到某个固定编号，根据这个编号作为找对应服务器
		⑥数据分片，例子1：统计关键词出现次数，在1T的日志文件里，快速统计关键词被搜索的次数。
				方案：数据分片，多台机器处理。将搜索关键词计算出哈希值，再对n取模，得到的编号为机器编号，哈希值相同的就被分配到同一台服务器上
			例子2：快速判断图片是否在图库中
				方案：数据分片+多机处理。图片计算哈希值，再与n台机器求余取模，得到的值就是机器编号，将图片唯一标识和图片路径放在这台机器的散列表里
					查找时同理，计算这张图片的唯一标识，再求余取模，得到机器编号，去该机器里找
		⑦ 分布式存储：原本根据机器取模的逻辑，当数据变多，需要扩容增加机器时，原本的就需要全部重算哈希值再搬到新机器上
		方案：一致性哈希算法，将服务器节点和数据项都映射到一个圆环上，每个服务器对应圆环上一段区间
		数据存放在第一个大于或等于该哈希值的服务器节点上，当有新增服务器或者减少时，就重新分配服务器节点上的数据项，减少全量重新计算的成本

2.树：非线性表数据结构
   高度：从地平面往上
   深度：从水平面往下
   层：跟深度相同，但初始是1
 ①二叉树：每个节点最多只有两个节点，左节点和右节点。
   满二叉树：所有节点都在最下面一层，且都有左右节点
   完全二叉树：叶子节点都在最后两层，且最后一层靠左排列，而且除了最后一层，其他层的节点是满的。（最适合数组顺序存储，节省内存）
 ②遍历二叉树：（复杂度是O(n)）
   前序遍历是指，对于树中的任意节点来说，先打印这个节点，然后再打印它的左子树，最后打印它的右子树。
   中序遍历是指，对于树中的任意节点来说，先打印它的左子树，然后再打印它本身，最后打印它的右子树。
   后序遍历是指，对于树中的任意节点来说，先打印它的左子树，然后再打印它的右子树，最后打印这个节点本身。
   总结：说的都是针对本身节点，前就是本身在前，中就是本身在中，后就是本身在后
   
 ③二叉查找树（二叉搜索树）：比节点小的存左节点，比节点大的存右节点
   查：跟节点对比，比节点大往右节点找，反之亦然
   增：跟节点对比，比节点大则找右节点，若空则新增
   删：1）没有子节点，直接删；2）一个子节点，替换被删除的节点；3）两个子节点，将右子树中最小节点作为替换节点
 ④重复数据二叉树：（例如存放两个18）
	方案一：二叉树节点存储多个数据，用链表或者支持动态扩容的数组等数据结构
	方案二：遇到相同时，将其放入右子树，当做比节点大处理
 ⑤二叉树相比散列表：1）散列无序，二叉树有序；
				  2）散列扩容消耗多，遇到散列冲突时性能不稳定；虽然是o(n)查找，但是加上哈希函数和哈希冲突，不一定比平衡二叉树快
				  3）散列表构造比二叉查找树复杂，考虑东西多，例如散列函数涉及、哈希冲突解决办法、扩容、缩容；二叉树只要考虑平衡，解决方案比较成熟、固定
3.红黑树
 ①平衡二叉树：二叉树中任意一个节点的左右子树的高度相差不能大于1
   平衡”的意思，其实就是让整棵树左右看起来比较“对称”、比较“平衡”，不要出现左子树很高、右子树很矮的情况。这样就能让整棵树的高度相对来说低一些，相应的插入、删除、查找等操作的效率高一些。
 ②红黑树：
	根节点是黑色的；
    每个叶子节点都是黑色的空节点（NIL），也就是说，叶子节点不存储数据；
    任何相邻的节点都不能同时为红色，也就是说，红色节点是被黑色节点隔开的；
    每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点；
  左旋、右旋：为了恢复树的平衡性
 ③：插入，删除操作，需要进行平衡调整
4.递归树

5.堆和堆排序
	①堆是一个完全二叉树；
	②堆中每一个节点的值都必须大于等于（或小于等于）其子树中每个节点的值。
 存储方式：数组
 插入：向上或向下，对比交换
 删除，把最后一个节点放到删除的位置，然后堆化对比交换
堆排序：建堆，排序 
堆的应用一：优先级队列：优先级高的先出队（即堆顶）
		1.合并有序小文件：从所有文件中各取一个字符串，放入数组，堆化，然后取堆顶放入大文件中，再以此类推。
		2.高性能定时器：旧方式：每秒扫一次，很浪费资源。
		新做法：将任务设定执行的时间，放入优先级队列，顶堆就是最先执行的，第一次扫只需要取顶堆的时间与当前时间相减得到时间间隔T，就可以T秒之后再来执行任务，中间间隔的时间就不用做任何事情，这样定时器不用每秒都轮询，也不用遍历整个任务列表，性能就提高了
堆的应用二：利用堆求Top K ：分为静态数据和动态数据两种
		如何在一个包含n个数据的数组中，查找前K大数据呢？
		方式：维护一个小顶堆，遍历数组，每个元素与堆顶对比，比堆顶大，则删除堆顶，元素入堆；如果比堆顶小，不做处理

堆的应用三：利用堆求中位数
		维护两个堆，一个大顶堆，一个小顶堆。大顶堆中存储前半部分数据，小顶堆中存储后半部分数据，且小顶堆中的数据都大于大顶堆中的数据。
		如何是奇数，大顶堆的堆顶就是中位数。如果是偶数，大顶堆的堆顶就是n/2+1，小顶堆的堆顶就是n/2
		如果数据是变化的，则对比堆顶元素入堆，会出现数量不同情况，就需要元素移动到另一个堆。
	拓展：求99%响应时间
	类似求中位数，只不过阈值往后挪，变成99%作为分割点，依旧是一个大顶堆，一个小顶堆，假设当前总数据的个数是n，大顶堆中保存n*99%个数据，小顶堆中保存n*1%个数据。大顶堆堆顶的数据就是我们要找的99%响应时间。
综合应用：假设现在我们有一个包含10亿个搜索关键词的日志文件，如何快速获取到Top 10最热门的搜索关键词呢？如果我们将处理的场景限定为单机，可以使用的内存为1GB。那这个问题该如何解决呢？
	方案：1.拆分为10个文件，通过哈希算法获取哈希值，再取模，得到的就是这个关键词分配的文件编号。
	     2.用散列表存储关键词出现次数 ，扫描关键词，若存在则+1，不存在则插入
		 3.用堆求Top K
		 4.将所有top10放一起，取次数最多的10个

6.图
	无向图，有向图，带权图
	存储方式：邻接矩阵（存储方式简单、直接、高效，但浪费空间）、邻接表（节省空间，但耗时间）
	
7.字符串匹配
  BF算法：Brute Force，暴力匹配算法，逐个匹配
  RK算法：Rabin-Karp算法，每个字符组计算成哈希值，寻找相同的哈希值
  BM算法：①坏字符规则：从目标串中倒序匹配，若是不匹配，则判断该字符在目标串中是否有出现，有则以目标位的位置往后滑动，没有则整个目标串滑动
		 ②好后缀规则：在好后缀中，找一个最长的与目标串中的前缀匹配的，以它为标准往后滑动
	  最核心的内容：
		①在模式串中，查找跟好后缀匹配的另一个子串；
		②在好后缀的后缀子串中，查找最长的、能跟模式串前缀子串匹配的后缀子串；

8.Trie树:Trie树是一种解决字符串快速匹配问题的数据结构。如果用来构建Trie树的这一组字符串中，前缀重复的情况不是很多，那Trie树这种数据结构总体上来讲是比较费内存的，是一种空间换时间的解决问题思路。
	场景：索引擎的搜索关键词提示功能（最简单的算法之一）


 
